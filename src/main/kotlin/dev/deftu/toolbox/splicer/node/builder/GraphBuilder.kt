package dev.deftu.toolbox.splicer.node.builder

import dev.deftu.toolbox.splicer.resolve
import org.gradle.api.Action
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.initialization.Settings
import org.gradle.api.provider.Property
import org.gradle.api.provider.Provider
import org.gradle.api.tasks.Input
import java.io.File

abstract class GraphBuilder {

    /**
     * Defines the core project definition that is used to create the root
     * project of this graph. This is typically a [ProjectReference][dev.deftu.toolbox.splicer.ProjectReference],
     * [String], [Provider][org.gradle.api.provider.Provider],
     * [File][java.io.File]
     */
    @get:Input
    abstract val coreProjectDefinition: Property<Any>

    /**
     * Defines the root buildscript file given to Gradle for the root project
     * of this graph. In your average Gradle project, this would be your
     * `build.gradle.kts` in a submodule, such as:
     */
    @get:Input
    abstract val rootBuildScript: RegularFileProperty

    /**
     * Defines the central buildscript file that is used for all nodes in this
     * graph. This is typically a `build.gradle.kts` file in the root project
     * of the graph, which is used to define common configurations for all
     * subprojects.
     */
    @get:Input
    abstract val centralBuildScript: RegularFileProperty

    /**
     * Directory where auto-generated projects are placed. This is typically
     * used for projects that are generated by the Splicer, such as those
     * defined in the `node` method which weren't created by you.
     */
    @get:Input
    abstract val autoProjectsDirectory: DirectoryProperty

    abstract fun root(node: NodeBuilder): NodeBuilder

    abstract fun node(name: String, version: Int, action: Action<NodeBuilder>?): NodeBuilder

    abstract fun dumpTree()

    fun node(name: String, version: Int): NodeBuilder {
        return node(name, version, null)
    }

    protected fun resolveCoreProjectDefinition(settings: Settings): File {
        return when (val coreProjectDefinition = this.coreProjectDefinition.get()) {
            is File -> coreProjectDefinition
            is String -> {
                val project = settings.findProject(coreProjectDefinition)
                project?.projectDir ?: File(coreProjectDefinition)
            }

            is Provider<*> -> {
                val value = coreProjectDefinition.get()
                when (value) {
                    is File -> value
                    is String -> {
                        val project = settings.findProject(value)
                        project?.projectDir ?: File(value)
                    }

                    else -> throw IllegalArgumentException("Unsupported core project definition type: ${value::class.java}")
                }
            }

            else -> coreProjectDefinition.resolve(settings).projectDir
        }
    }

}
